declare module "leapjs" {
    /**
     * When creating a Controller object, you may optionally pass in options
     * to set the host , set the port, or select the frame event type.
     *
     * ```javascript
     * var controller = new Leap.Controller({
     *   host: '127.0.0.1',
     *   port: 6437,
     *   frameEventName: 'animationFrame'
     * });
     * ```
     *
     * @class Controller
     * @memberof Leap
     * @classdesc
     * The Controller class is your main interface to the Leap Motion Controller.
     *
     * Create an instance of this Controller class to access frames of tracking data
     * and configuration information. Frame data can be polled at any time using the
     * [Controller.frame]{@link Leap.Controller#frame}() function. Call frame() or frame(0) to get the most recent
     * frame. Set the history parameter to a positive integer to access previous frames.
     * A controller stores up to 60 frames in its frame history.
     *
     * Polling is an appropriate strategy for applications which already have an
     * intrinsic update loop, such as a game.
     *
     * loopWhileDisconnected defaults to true, and maintains a 60FPS frame rate even when Leap Motion is not streaming
     * data at that rate (such as no hands in frame).  This is important for VR/WebGL apps which rely on rendering for
     * regular visual updates, including from other input devices.  Flipping this to false should be considered an
     * optimization for very specific use-cases.
     *
     *
     */
    export class Controller extends import("events").EventEmitter {
      constructor(opts: {
        inNode?: boolean;
        frameEventName?: "animationFrame" | "deviceFrame";
        suppressAnimationLoop?: boolean;
        loopWhileDisconnected?: boolean;
        useAllPlugins?: boolean;
        checkVersion?: boolean;
      });
      animationFrameRequested: boolean;
      onAnimationFrame(timestamp: number): void;
      suppressAnimationLoop: boolean;
      loopWhileDisconnected: boolean;
      frameEventName: "animationFrame" | "deviceFrame";
      useAllPlugins: boolean;
      history: CircularBuffer;
      lastFrame: Frame;
      lastValidFrame: Frame;
      lastConnectionFrame: Frame;
      checkVersion: boolean;
      //   connectionType = opts.connectionType;
      //   connection = new this.connectionType(opts);
      streamingCount: number;
      devices: {};
      plugins = {};
      //   this._pluginPipelineSteps = {};
      //   this._pluginExtendedMethods = {};
      setBackground(state: any): this;
      setOptimizeHMD(state: any): this;
      inBrowser(): boolean;
      useAnimationLoop(): boolean;
      inBackgroundPage(): boolean;
      connect(): this;
      streaming(): boolean;
      connected(): boolean;
      startAnimationLoop(): void;
      disconnect(): this;
      frame(num: number): Frame;
      loop(callback?: { [eventName: string]: Function } | Function): this;
      addStep(step): void;
      processFinishedFrame(frame: Frame): void;
      emitHandEvents(frame: Frame): void;
      setupFrameEvents(opts: any): void;
      setupConnectionEvents(): void;
      checkOutOfDate(): boolean;
      plugin<Factory extends Function>(
        pluginName: string,
        factory: Factory
      ): Factory;
      plugins(): string[];
      use(pluginName: string, options: any): this;
      stopUsing(pluginName: string): this;
      useRegisteredPlugins(): void;
    }
    /**
     * Frame instances created with this constructor are invalid.
     * Get valid Frame objects by calling the
     * [Controller.frame]{@link Leap.Controller#frame}() function.
     *<C-D-Space>
     * @class Frame
     * @memberof Leap
     * @classdesc
     * The Frame class represents a set of hand and finger tracking data detected
     * in a single frame.
     *
     * The Leap detects hands, fingers within the tracking area, reporting
     * their positions, orientations and motions in frames at the Leap frame rate.
     *
     * Access Frame objects using the [Controller.frame]{@link Leap.Controller#frame}() function.
     */
    export class Frame {
      constructor(data: Frame["data"]);
      data: {
        id: string;
        timestamp: number;
        t?: any;
        r?: any;
        s?: any;
        currentFrameRate: number;
        pointables: Pointable[];
      };
      /**
       * Reports whether this Frame instance is valid.
       *
       * A valid Frame is one generated by the Controller object that contains
       * tracking data for all detected entities. An invalid Frame contains no
       * actual tracking data, but you can call its functions without risk of a
       * undefined object exception. The invalid Frame mechanism makes it more
       * convenient to track individual data across the frame history. For example,
       * you can invoke:
       *
       * ```javascript
       * var finger = controller.frame(n).finger(fingerID);
       * ```
       *
       * for an arbitrary Frame history value, "n", without first checking whether
       * frame(n) returned a null object. (You should still check that the
       * returned Finger instance is valid.)
       *
       * @member valid
       * @type {Boolean}
       */
      valid: boolean;
      /**
       * A unique ID for this Frame. Consecutive frames processed by the Leap
       * have consecutive increasing values.
       * @member id
       * @memberof Leap.Frame.prototype
       * @type {String}
       */
      id: string;
      /**
       * The frame capture time in microseconds elapsed since the Leap started.
       * @member timestamp
       * @memberof Leap.Frame.prototype
       * @type {number}
       */
      timestamp: number;
      /**
       * The list of Hand objects detected in this frame, given in arbitrary order.
       * The list can be empty if no hands are detected.
       *
       * @member hands[]
       * @memberof Leap.Frame.prototype
       * @type {Leap.Hand}
       */
      hands: Hand[];
      handsmap: {};
      /**
       * The list of Pointable objects (fingers) detected in this frame,
       * given in arbitrary order. The list can be empty if no fingers are
       * detected.
       *
       * @member pointables[]
       * @memberof Leap.Frame.prototype
       * @type {Leap.Pointable}
       */
      pointables: Pointable[];
      pointablesMap: {};
      /**
       * The list of Finger objects detected in this frame, given in arbitrary order.
       * The list can be empty if no fingers are detected.
       * @member fingers[]
       * @memberof Leap.Frame.prototype
       * @type {Leap.Pointable}
       */
      fingers: Finger[];
      /**
       * The InteractionBox associated with the current frame.
       *
       * @member interactionBox
       * @memberof Leap.Frame.prototype
       * @type {Leap.InteractionBox}
       */
      interactionBox?: InteractionBox;
      currentFrameRate: number;
      /**
       * used by event emitting
       */
      type: "frame";
  
      postprocessData(data?: Frame["data"]);
      /**
       * Adds data from a pointable element into the pointablesMap;
       * also adds the pointable to the frame.handsMap hand to which it belongs,
       * and to the hand's fingers map.
       *
       * @param pointable {Pointable} a Pointable
       */
      addPointable(pointable: Pointable): void;
      /**
       * The Pointable object with the specified ID in this frame.
       *
       * Use the Frame pointable() function to retrieve the Pointable object from
       * this frame using an ID value obtained from a previous frame.
       * This function always returns a Pointable object, but if no finger
       * with the specified ID is present, an invalid Pointable object is returned.
       *
       * Note that ID values persist across frames, but only until tracking of a
       * particular object is lost. If tracking of a finger is lost and subsequently
       * regained, the new Pointable object representing that finger may have
       * a different ID than that representing the finger in an earlier frame.
       *
       * @method pointable
       * @param {String} id The ID value of a Pointable object from a previous frame.
       * @returns {Pointable} The Pointable object with
       * the matching ID if one exists in this frame;
       * otherwise, an invalid Pointable object is returned.
       */
      pointable(id: string): Pointable;
      /**
       * The finger with the specified ID in this frame.
       *
       * Use the Frame finger() function to retrieve the finger from
       * this frame using an ID value obtained from a previous frame.
       * This function always returns a Finger object, but if no finger
       * with the specified ID is present, an invalid Pointable object is returned.
       *
       * Note that ID values persist across frames, but only until tracking of a
       * particular object is lost. If tracking of a finger is lost and subsequently
       * regained, the new Pointable object representing that physical finger may have
       * a different ID than that representing the finger in an earlier frame.
       *
       * @method finger
       * @param {String} id The ID value of a finger from a previous frame.
       * @returns {Pointable} The finger with the
       * matching ID if one exists in this frame; otherwise, an invalid Pointable
       * object is returned.
       */
      finger(id: string): ReturnType<Frame["pointable"]>;
      /**
       * The Hand object with the specified ID in this frame.
       *
       * Use the Frame hand() function to retrieve the Hand object from
       * this frame using an ID value obtained from a previous frame.
       * This function always returns a Hand object, but if no hand
       * with the specified ID is present, an invalid Hand object is returned.
       *
       * Note that ID values persist across frames, but only until tracking of a
       * particular object is lost. If tracking of a hand is lost and subsequently
       * regained, the new Hand object representing that physical hand may have
       * a different ID than that representing the physical hand in an earlier frame.
       *
       * @method hand
       * @param {String} id The ID value of a Hand object from a previous frame.
       * @returns {Hand} The Hand object with the matching
       * ID if one exists in this frame; otherwise, an invalid Hand object is returned.
       */
      hand(id: string): Hand;
      /**
       * The angle of rotation around the rotation axis derived from the overall
       * rotational motion between the current frame and the specified frame.
       *
       * The returned angle is expressed in radians measured clockwise around
       * the rotation axis (using the right-hand rule) between the start and end frames.
       * The value is always between 0 and pi radians (0 and 180 degrees).
       *
       * The Leap derives frame rotation from the relative change in position and
       * orientation of all objects detected in the field of view.
       *
       * If either this frame or sinceFrame is an invalid Frame object, then the
       * angle of rotation is zero.
       *
       * @method rotationAngle
       * @param {Frame} sinceFrame The starting frame for computing the relative rotation.
       * @param {number[]} [axis] The axis to measure rotation around.
       * @returns {number} A positive value containing the heuristically determined
       * rotational change between the current frame and that specified in the sinceFrame parameter.
       */
      rotationAngle(sinceFrame: Frame, axis: number[]): number;
      /**
       * The axis of rotation derived from the overall rotational motion between
       * the current frame and the specified frame.
       *
       * The returned direction vector is normalized.
       *
       * The Leap derives frame rotation from the relative change in position and
       * orientation of all objects detected in the field of view.
       *
       * If either this frame or sinceFrame is an invalid Frame object, or if no
       * rotation is detected between the two frames, a zero vector is returned.
       *
       * @method rotationAxis
       * @param {Frame} sinceFrame The starting frame for computing the relative rotation.
       * @returns {import("gl-matrix").vec3} A normalized direction vector representing the axis of the heuristically determined
       * rotational change between the current frame and that specified in the sinceFrame parameter.
       */
      rotationAxis(sinceFrame: Frame): import("gl-matrix").vec3;
      /**
       * The transform matrix expressing the rotation derived from the overall
       * rotational motion between the current frame and the specified frame.
       *
       * The Leap derives frame rotation from the relative change in position and
       * orientation of all objects detected in the field of view.
       *
       * If either this frame or sinceFrame is an invalid Frame object, then
       * this method returns an identity matrix.
       *
       * @method rotationMatrix
       * @param {Frame} sinceFrame The starting frame for computing the relative rotation.
       * @returns {import("gl-matrix").mat3} A transformation matrix containing the heuristically determined
       * rotational change between the current frame and that specified in the sinceFrame parameter.
       */
      rotationMatrix(sinceFrame: Frame): import("gl-matrix").mat3;
      /**
       * The scale factor derived from the overall motion between the current frame and the specified frame.
       *
       * The scale factor is always positive. A value of 1.0 indicates no scaling took place.
       * Values between 0.0 and 1.0 indicate contraction and values greater than 1.0 indicate expansion.
       *
       * The Leap derives scaling from the relative inward or outward motion of all
       * objects detected in the field of view (independent of translation and rotation).
       *
       * If either this frame or sinceFrame is an invalid Frame object, then this method returns 1.0.
       *
       * @method scaleFactor
       * @param {Frame} sinceFrame The starting frame for computing the relative scaling.
       * @returns {number} A positive value representing the heuristically determined
       * scaling change ratio between the current frame and that specified in the sinceFrame parameter.
       */
      scaleFactor(sinceFrame: Frame): number;
      /**
       * The change of position derived from the overall linear motion between the
       * current frame and the specified frame.
       *
       * The returned translation vector provides the magnitude and direction of the
       * movement in millimeters.
       *
       * The Leap derives frame translation from the linear motion of all objects
       * detected in the field of view.
       *
       * If either this frame or sinceFrame is an invalid Frame object, then this
       * method returns a zero vector.
       *
       * @method translation
       * @param {Frame} sinceFrame The starting frame for computing the relative translation.
       * @returns {number[]} A vector representing the heuristically determined change in
       * position of all objects between the current frame and that specified in the sinceFrame parameter.
       */
      translation(sinceFrame: Frame): import("gl-matrix").vec3;
      /**
       * A string containing a brief, human readable description of the Frame object.
       *
       * @method toString
       * @returns {String} A brief description of this frame.
       */
      toString(): string;
      /**
       * Returns a JSON-formatted string containing the hands, pointables
       * in this frame.
       *
       * @method dump
       * @returns {String} A JSON-formatted string.
       */
      dump(): string;
      /**
       * An invalid Frame object.
       *
       * You can use this invalid Frame in comparisons testing
       * whether a given Frame instance is valid or invalid. (You can also check the
       * [Frame.valid]{@link Leap.Frame#valid} property.)
       *
       * @static
       * @type {Frame}
       * @name Invalid
       */
      static Invalid: {
        valid: false;
        hands: Hand[];
        fingers: Finger[];
        pointables: Pointable[];
        pointable: () => Pointable.Invalid;
        finger: () => Pointable.Invalid;
        hand: () => Hand.Invalid;
        toString: () => "invalid frame";
        dump: () => string;
        rotationAngle: () => 0.0;
        rotationMatrix: () => import("gl-matrix").mat3;
        rotationAxis: () => import("gl-matrix").vec3;
        scaleFactor: () => 1.0;
        translation: () => import("gl-matrix").vec3;
      };
    }
    /**
     * An uninitialized hand is considered invalid.
     * Get valid Hand objects from a Frame object.
     * @class Hand
     * @memberof Leap
     * @classdesc
     * The Hand class reports the physical characteristics of a detected hand.
     *
     * Hand tracking data includes a palm position and velocity; vectors for
     * the palm normal and direction to the fingers; properties of a sphere fit
     * to the hand; and lists of the attached fingers.
     *
     * Note that Hand objects can be invalid, which means that they do not contain
     * valid tracking data and do not correspond to a physical entity. Invalid Hand
     * objects can be the result of asking for a Hand object using an ID from an
     * earlier frame when no Hand objects with that ID exist in the current frame.
     * A Hand object created from the Hand constructor is also invalid.
     * Test for validity with the [Hand.valid]{@link Leap.Hand#valid} property.
     */
    export class Hand {
      /**
       * A unique ID assigned to this Hand object, whose value remains the same
       * across consecutive frames while the tracked hand remains visible. If
       * tracking is lost (for example, when a hand is occluded by another hand
       * or when it is withdrawn from or reaches the edge of the Leap field of view),
       * the Leap may assign a new ID when it detects the hand in a future frame.
       *
       * Use the ID value with the {@link Frame.hand}() function to find this
       * Hand object in future frames.
       *
       * @member id
       * @type {String}
       */
      id: string;
      /**
       * The center position of the palm in millimeters from the Leap origin.
       * @member palmPosition
       * @type {number[]}
       */
      palmPosition: number[];
      /**
       * The direction from the palm position toward the fingers.
       *
       * The direction is expressed as a unit vector pointing in the same
       * direction as the directed line from the palm position to the fingers.
       *
       * @member direction
       * @type {number[]}
       */
      direction: number[];
      /**
       * The rate of change of the palm position in millimeters/second.
       *
       * @member palmVeclocity
       * @type {number[]}
       */
      palmVeclocity: number[];
      /**
       * The normal vector to the palm. If your hand is flat, this vector will
       * point downward, or "out" of the front surface of your palm.
       *
       * ![Palm Vectors](images/Leap_Palm_Vectors.png)
       *
       * The direction is expressed as a unit vector pointing in the same
       * direction as the palm normal (that is, a vector orthogonal to the palm).
       * @member palmNormal
       * @memberof Leap.Hand.prototype
       * @type {number[]}
       */
      palmNormal: number[];
      /**
       * The center of a sphere fit to the curvature of this hand.
       *
       * This sphere is placed roughly as if the hand were holding a ball.
       *
       * ![Hand Ball](images/Leap_Hand_Ball.png)
       * @member sphereCenter
       * @type {number[]}
       */
      sphereCenter: number[];
      /**
       * The radius of a sphere fit to the curvature of this hand, in millimeters.
       *
       * This sphere is placed roughly as if the hand were holding a ball. Thus the
       * size of the sphere decreases as the fingers are curled into a fist.
       *
       * @member sphereRadius
       * @type {number}
       */
      sphereRadius: number;
      /**
       * Reports whether this is a valid Hand object.
       *
       * @member valid
       * @type {boolean}
       */
      valid: boolean;
      /**
       * The list of Pointable objects (fingers) detected in this frame
       * that are associated with this hand, given in arbitrary order. The list
       * can be empty if no fingers or tools associated with this hand are detected.
       *
       * Use the {@link Pointable} tool property to determine
       * whether or not an item in the list represents a tool or finger.
       * You can also get only the fingers using the Hand.fingers[] list.
       *
       * @member pointables[]
       * @type {Leap.Pointable[]}
       */
      pointables: Pointable[];
      /**
       * The list of fingers detected in this frame that are attached to
       * this hand, given in arbitrary order.
       *
       * The list can be empty if no fingers attached to this hand are detected.
       *
       * @member fingers[]
       * @type {Leap.Pointable[]}
       */
      fingers: Finger[];
      arm: null | Bone;
      /**
       * Time the hand has been visible in seconds.
       *
       * @member timeVisible
       * @type {number}
       */
      timeVisible: number;
      /**
       * The palm position with stabalization
       * @member stabilizedPalmPositio
       * @type {number[]}
       */
      stabilizedPalmPosition: number[];
      /**
       * Reports whether this is a left or a right hand.
       *
       * @member type
       * @type {String}
       */
      type: string;
      /**
       * The finger with the specified ID attached to this hand.
       *
       * Use this function to retrieve a Pointable object representing a finger
       * attached to this hand using an ID value obtained from a previous frame.
       * This function always returns a Pointable object, but if no finger
       * with the specified ID is present, an invalid Pointable object is returned.
       *
       * Note that the ID values assigned to fingers persist across frames, but only
       * until tracking of a particular finger is lost. If tracking of a finger is
       * lost and subsequently regained, the new Finger object representing that
       * finger may have a different ID than that representing the finger in an
       * earlier frame.
       *
       * @method finger
       * @param {String} id The ID value of a finger from a previous frame.
       * @returns {Pointable} The Finger object with
       * the matching ID if one exists for this hand in this frame; otherwise, an
       * invalid Finger object is returned.
       */
      finger(id: string): Pointable;
      /**
       * The angle of rotation around the rotation axis derived from the change in
       * orientation of this hand, and any associated fingers, between the
       * current frame and the specified frame.
       *
       * The returned angle is expressed in radians measured clockwise around the
       * rotation axis (using the right-hand rule) between the start and end frames.
       * The value is always between 0 and pi radians (0 and 180 degrees).
       *
       * If a corresponding Hand object is not found in sinceFrame, or if either
       * this frame or sinceFrame are invalid Frame objects, then the angle of rotation is zero.
       *
       * @method rotationAngle
       * @param {Frame} sinceFrame The starting frame for computing the relative rotation.
       * @param {number[]} [axis] The axis to measure rotation around.
       * @returns {number} A positive value representing the heuristically determined
       * rotational change of the hand between the current frame and that specified in
       * the sinceFrame parameter.
       */
      rotationAngle(sinceFrame: Frame, axis: number[]): number;
      /**
       * The axis of rotation derived from the change in orientation of this hand, and
       * any associated fingers, between the current frame and the specified frame.
       *
       * The returned direction vector is normalized.
       *
       * If a corresponding Hand object is not found in sinceFrame, or if either
       * this frame or sinceFrame are invalid Frame objects, then this method returns a zero vector.
       *
       * @method rotationAxis
       * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.
       * @returns {import("gl-matrix").vec3} A normalized direction Vector representing the axis of the heuristically determined
       * rotational change of the hand between the current frame and that specified in the sinceFrame parameter.
       */
      rotationAxis(sinceFrame: Frame): import("gl-matrix").vec3;
      /**
       * The transform matrix expressing the rotation derived from the change in
       * orientation of this hand, and any associated fingers, between
       * the current frame and the specified frame.
       *
       * If a corresponding Hand object is not found in sinceFrame, or if either
       * this frame or sinceFrame are invalid Frame objects, then this method returns
       * an identity matrix.
       *
       * @method rotationMatrix
       * @param {Leap.Frame} sinceFrame The starting frame for computing the relative rotation.
       * @returns {import("gl-matrix").mat3} A transformation Matrix containing the heuristically determined
       * rotational change of the hand between the current frame and that specified in the sinceFrame parameter.
       */
      rotationMatrix(sinceFrame: Frame): import("gl-matrix").mat3;
      /**
       * The scale factor derived from the hand's motion between the current frame and the specified frame.
       *
       * The scale factor is always positive. A value of 1.0 indicates no scaling took place.
       * Values between 0.0 and 1.0 indicate contraction and values greater than 1.0 indicate expansion.
       *
       * The Leap derives scaling from the relative inward or outward motion of a hand
       * and its associated fingers (independent of translation and rotation).
       *
       * If a corresponding Hand object is not found in sinceFrame, or if either this frame or sinceFrame
       * are invalid Frame objects, then this method returns 1.0.
       *
       * @method scaleFactor
       * @param {Leap.Frame} sinceFrame The starting frame for computing the relative scaling.
       * @returns {number} A positive value representing the heuristically determined
       * scaling change ratio of the hand between the current frame and that specified in the sinceFrame parameter.
       */
      scaleFactor(sinceFrame: Frame): number;
      /**
       * The change of position of this hand between the current frame and the specified frame
       *
       * The returned translation vector provides the magnitude and direction of the
       * movement in millimeters.
       *
       * If a corresponding Hand object is not found in sinceFrame, or if either this frame or
       * sinceFrame are invalid Frame objects, then this method returns a zero vector.
       *
       * @method translation
       * @param {Leap.Frame} sinceFrame The starting frame for computing the relative translation.
       * @returns {number[]} A Vector representing the heuristically determined change in hand
       * position between the current frame and that specified in the sinceFrame parameter.
       */
      translation(sinceFrame: Frame): import("gl-matrix").vec3;
      /**
       * A string containing a brief, human readable description of the Hand object.
       * @method toString
       * @returns {String} A description of the Hand as a string.
       */
      toString(): string;
  
      /**
       * The pitch angle in radians.
       *
       * Pitch is the angle between the negative z-axis and the projection of
       * the vector onto the y-z plane. In other words, pitch represents rotation
       * around the x-axis.
       * If the vector points upward, the returned angle is between 0 and pi radians
       * (180 degrees); if it points downward, the angle is between 0 and -pi radians.
       *
       * @method pitch
       * @returns {number} The angle of this vector above or below the horizon (x-z plane).
       *
       */
      pitch(): number;
      /**
       *  The yaw angle in radians.
       *
       * Yaw is the angle between the negative z-axis and the projection of
       * the vector onto the x-z plane. In other words, yaw represents rotation
       * around the y-axis. If the vector points to the right of the negative z-axis,
       * then the returned angle is between 0 and pi radians (180 degrees);
       * if it points to the left, the angle is between 0 and -pi radians.
       *
       * @method yaw
       * @returns {number} The angle of this vector to the right or left of the y-axis.
       *
       */
      yaw(): number;
      /**
       *  The roll angle in radians.
       *
       * Roll is the angle between the y-axis and the projection of
       * the vector onto the x-y plane. In other words, roll represents rotation
       * around the z-axis. If the vector points to the left of the y-axis,
       * then the returned angle is between 0 and pi radians (180 degrees);
       * if it points to the right, the angle is between 0 and -pi radians.
       *
       * @method roll
       * @returns {number} The angle of this vector to the right or left of the y-axis.
       *
       */
      roll(): number;
  
      /**
       * An invalid Hand object.
       *
       * You can use an invalid Hand object in comparisons testing
       * whether a given Hand instance is valid or invalid. (You can also use the
       * Hand valid property.)
       *
       * @static
       * @type {Leap.Hand}
       * @name Invalid
       * @memberof Leap.Hand
       */
      static Invalid: {
        valid: false;
        fingers: Finger[];
        pointables: Pointable[];
        left: false;
        pointable(): Pointable.Invalid;
        finger(): Pointable.Invalid;
        toString(): string;
        dump(): string;
        rotationAngle(): 0.0;
        rotationMatrix(): import("gl-matrix").mat3;
        rotationAxis(): import("gl-matrix").vec3;
        scaleFactor(): 1.0;
        translation(): import("gl-matrix").vec3;
      };
    }
    class Bone {
      constructor(
        public finger: Finger,
        data: {
          type: Bone["type"];
          prevJoint: Bone["prevJoint"];
          nextJoint: Bone["nextJoint"];
          width: Bone["width"];
          basis: Bone["basis"];
        }
      );
  
      /**
       * An integer code for the name of this bone.
       *
       * * 0 -- metacarpal
       * * 1 -- proximal
       * * 2 -- medial
       * * 3 -- distal
       * * 4 -- arm
       *
       * @member type
       * @type {number}
       * @memberof Leap.Bone.prototype
       */
      type: 0 | 1 | 2 | 3 | 4;
  
      /**
       * The position of the previous, or base joint of the bone closer to the wrist.
       * @type {vector3}
       */
      prevJoint: import("gl-matrix").vec3;
  
      /**
       * The position of the next joint, or the end of the bone closer to the finger tip.
       * @type {vector3}
       */
      nextJoint: import("gl-matrix").vec3;
  
      /**
       * The estimated width of the pointable in millimeters.
       *
       * The reported width is the average width of the visible portion of the
       * pointable from the hand to the tip. If the width isn't known,
       * then a value of 0 is returned.
       *
       * Bone objects representing fingers do not have a width property.
       *
       * @member width
       * @type {number}
       * @memberof Leap.Pointable.prototype
       */
      width: number;
  
      length: number;
  
      /**
       *
       * These fully-specify the orientation of the bone.
       * See examples/threejs-bones.html for more info
       * Three vec3s:
       *  x (red): The rotation axis of the finger, pointing outwards.  (In general, away from the thumb )
       *  y (green): The "up" vector, orienting the top of the finger
       *  z (blue): The roll axis of the bone.
       *
       *  Most up vectors will be pointing the same direction, except for the thumb, which is more rightwards.
       *
       *  The thumb has one fewer bones than the fingers, but there are the same number of joints & joint-bases provided
       *  the first two appear in the same position, but only the second (proximal) rotates.
       *
       *  Normalized.
       */
      basis: import("gl-matrix").vec3;
  
      left(): boolean;
      matrix(): import("gl-matrix").mat4;
      lerp(out: import("gl-matrix").vec3, t: number): import("gl-matrix").vec3;
      center(): import("gl-matrix").vec3;
      direction(): import("gl-matrix").vec3;
    }
    /**
     * An uninitialized pointable is considered invalid.
     * Get valid Pointable objects from a Frame or a Hand object.
     *
     * @class Pointable
     * @memberof Leap
     * @classdesc
     * The Pointable class reports the physical characteristics of a detected
     * finger or tool.
     *
     * Both fingers and tools are classified as Pointable objects. Use the
     * Pointable.tool property to determine whether a Pointable object represents a
     * tool or finger. The Leap classifies a detected entity as a tool when it is
     * thinner, straighter, and longer than a typical finger.
     *
     * Note that Pointable objects can be invalid, which means that they do not
     * contain valid tracking data and do not correspond to a physical entity.
     * Invalid Pointable objects can be the result of asking for a Pointable object
     * using an ID from an earlier frame when no Pointable objects with that ID
     * exist in the current frame. A Pointable object created from the Pointable
     * constructor is also invalid. Test for validity with the Pointable.valid
     * property.
     */
    export class Pointable {
      constructor(data);
      /**
       * Indicates whether this is a valid Pointable object.
       *
       * @member valid
       * @type {Boolean}
       */
      valid: boolean;
      /**
       * A unique ID assigned to this Pointable object, whose value remains the
       * same across consecutive frames while the tracked finger or tool remains
       * visible. If tracking is lost (for example, when a finger is occluded by
       * another finger or when it is withdrawn from the Leap field of view), the
       * Leap may assign a new ID when it detects the entity in a future frame.
       *
       * Use the ID value with the pointable() functions defined for the
       * {@link Frame} and {@link Frame.Hand} classes to find this
       * Pointable object in future frames.
       *
       * @member id
       * @type {String}
       */
      id: string;
      handId: string;
      /**
       * The estimated length of the finger or tool in millimeters.
       *
       * The reported length is the visible length of the finger or tool from the
       * hand to tip. If the length isn't known, then a value of 0 is returned.
       *
       * @member length
       * @type {number}
       */
      length: number;
      /**
       * Whether or not the Pointable is believed to be a tool.
       * Tools are generally longer, thinner, and straighter than fingers.
       *
       * If tool is false, then this Pointable must be a finger.
       *
       * @member tool
       * @type {Boolean}
       */
      tool: boolean;
      /**
       * The estimated width of the tool in millimeters.
       *
       * The reported width is the average width of the visible portion of the
       * tool from the hand to the tip. If the width isn't known,
       * then a value of 0 is returned.
       *
       * Pointable objects representing fingers do not have a width property.
       *
       * @member width
       * @type {number}
       */
      width: number;
      /**
       * The direction in which this finger or tool is pointing.
       *
       * The direction is expressed as a unit vector pointing in the same
       * direction as the tip.
       *
       * ![Finger](images/Leap_Finger_Model.png)
       * @member direction
       * @type {number[]}
       */
      direction: number[];
      /**
       * The tip position in millimeters from the Leap origin.
       * Stabilized
       *
       * @member stabilizedTipPosition
       * @type {number[]}
       */
      stabilizedTipPosition: number[];
      /**
       * The tip position in millimeters from the Leap origin.
       *
       * @member tipPosition
       * @type {number[]}
       */
      tipPosition: number[];
      /**
       * The rate of change of the tip position in millimeters/second.
       *
       * @member tipVelocity
       * @type {number[]}
       */
      tipVelocity: number[];
      /**
       * The current touch zone of this Pointable object.
       *
       * The Leap Motion software computes the touch zone based on a floating touch
       * plane that adapts to the user's finger movement and hand posture. The Leap
       * Motion software interprets purposeful movements toward this plane as potential touch
       * points. When a Pointable moves close to the adaptive touch plane, it enters the
       * "hovering" zone. When a Pointable reaches or passes through the plane, it enters
       * the "touching" zone.
       *
       * The possible states include:
       *
       * * "none" -- The Pointable is outside the hovering zone.
       * * "hovering" -- The Pointable is close to, but not touching the touch plane.
       * * "touching" -- The Pointable has penetrated the touch plane.
       *
       * The touchDistance value provides a normalized indication of the distance to
       * the touch plane when the Pointable is in the hovering or touching zones.
       *
       * @member touchZone
       * @type {String}
       */
      touchZone: string;
      /**
       * A value proportional to the distance between this Pointable object and the
       * adaptive touch plane.
       *
       * ![Touch Distance](images/Leap_Touch_Plane.png)
       *
       * The touch distance is a value in the range [-1, 1]. The value 1.0 indicates the
       * Pointable is at the far edge of the hovering zone. The value 0 indicates the
       * Pointable is just entering the touching zone. A value of -1.0 indicates the
       * Pointable is firmly within the touching zone. Values in between are
       * proportional to the distance from the plane. Thus, the touchDistance of 0.5
       * indicates that the Pointable is halfway into the hovering zone.
       *
       * You can use the touchDistance value to modulate visual feedback given to the
       * user as their fingers close in on a touch target, such as a button.
       *
       * @member touchDistance
       * @type {number}
       */
      touchDistance: number;
      /**
       * How long the pointable has been visible in seconds.
       *
       * @member timeVisible
       * @type {number}
       */
      timeVisible: number;
      /**
       * A string containing a brief, human readable description of the Pointable
       * object.
       *
       * @method toString
       * @returns {String} A description of the Pointable object as a string.
       */
      toString(): string;
      /**
       * Returns the hand which the pointable is attached to.
       */
      hand(): ReturnType<Frame["hand"]>;
      /**
   * An invalid Pointable object.
   *
   * You can use this Pointable instance in comparisons testing
   * whether a given Pointable instance is valid or invalid. (You can also use the
   * Pointable.valid property.)
  
   * @static
   * @type {Leap.Pointable}
   * @name Invalid
   */
      Invalid: { valid: false };
    }
    /**
     * An uninitialized finger is considered invalid.
     * Get valid Finger objects from a Frame or a Hand object.
     *
     * @class Finger
     * @memberof Leap
     * @classdesc
     * The Finger class reports the physical characteristics of a finger.
     *
     * Both fingers are classified as Pointable objects. Use the
     * Pointable.tool property to determine whether a Pointable object represents a
     * tool or finger. The Leap classifies a detected entity as a tool when it is
     * thinner, straighter, and longer than a typical finger.
     *
     * Note that Finger objects can be invalid, which means that they do not
     * contain valid tracking data and do not correspond to a physical entity.
     * Invalid Finger objects can be the result of asking for a Finger object
     * using an ID from an earlier frame when no Finger objects with that ID
     * exist in the current frame. A Finger object created from the Finger
     * constructor is also invalid. Test for validity with the Pointable.valid
     * property.
     */
    export class Finger extends Pointable {
      constructor(data: {
        dipPosition: Finger["dipPosition"];
        pipPosition: Finger["pipPosition"];
        mcpPosition: Finger["mcpPosition"];
        carpPosition: Finger["carpPosition"];
        extended: Finger["extended"];
        type: Finger["type"];
        bases?: Parameters<Finger["addBones"]>[0]["bases"];
      });
      /**
       * The position of the distal interphalangeal joint of the finger.
       * This joint is closest to the tip.
       *
       * The distal interphalangeal joint is located between the most extreme segment
       * of the finger (the distal phalanx) and the middle segment (the medial
       * phalanx).
       *
       * @member dipPosition
       * @type {number[]}
       */
      dipPosition: number[];
      /**
       * The position of the proximal interphalangeal joint of the finger. This joint is the middle
       * joint of a finger.
       *
       * The proximal interphalangeal joint is located between the two finger segments
       * closest to the hand (the proximal and the medial phalanges). On a thumb,
       * which lacks an medial phalanx, this joint index identifies the knuckle joint
       * between the proximal phalanx and the metacarpal bone.
       *
       * @member pipPosition
       * @type {number[]}
       */
      pipPosition: number[];
  
      /**
       * The position of the metacarpopophalangeal joint, or knuckle, of the finger.
       *
       * The metacarpopophalangeal joint is located at the base of a finger between
       * the metacarpal bone and the first phalanx. The common name for this joint is
       * the knuckle.
       *
       * On a thumb, which has one less phalanx than a finger, this joint index
       * identifies the thumb joint near the base of the hand, between the carpal
       * and metacarpal bones.
       *
       * @member mcpPosition
       * @type {number[]}
       */
      mcpPosition: number[];
      /**
       * The position of the Carpometacarpal joint
       *
       * This is at the distal end of the wrist, and has no common name.
       *
       */
      carpPosition: number[];
      /**
       * Whether or not this finger is in an extended posture.
       *
       * A finger is considered extended if it is extended straight from the hand as if
       * pointing. A finger is not extended when it is bent down and curled towards the
       * palm.
       * @member extended
       * @type {Boolean}
       */
      extended: boolean;
      /**
       * An integer code for the name of this finger.
       *
       * * 0 -- thumb
       * * 1 -- index finger
       * * 2 -- middle finger
       * * 3 -- ring finger
       * * 4 -- pinky
       *
       * @member type
       * @type {number}
       */
      type: 0 | 1 | 2 | 3 | 4;
      finger: true;
      /**
       * The joint positions of this finger as an array in the order base to tip.
       *
       * @member positions
       * @type {array[]}
       * @memberof Leap.Finger.prototype
       */
      positions: [number, number, number, number, number];
      bones: Bone[];
      addBones(data: { bases: number[] });
      toString(): string;
      Invalid: { valid: false };
    }
    /**
     * Constructs a InteractionBox object.
     *
     * @class InteractionBox
     * @memberof Leap
     * @classdesc
     * The InteractionBox class represents a box-shaped region completely within
     * the field of view of the Leap Motion controller.
     *
     * The interaction box is an axis-aligned rectangular prism and provides
     * normalized coordinates for hands, fingers, and tools within this box.
     * The InteractionBox class can make it easier to map positions in the
     * Leap Motion coordinate system to 2D or 3D coordinate systems used
     * for application drawing.
     *
     * ![Interaction Box](images/Leap_InteractionBox.png)
     *
     * The InteractionBox region is defined by a center and dimensions along the x, y, and z axes.
     */
    export class InteractionBox {
      constructor(data);
      /**
       * Indicates whether this is a valid InteractionBox object.
       *
       * @member valid
       * @type {Boolean}
       */
      valid: boolean;
      /**
       * The center of the InteractionBox in device coordinates (millimeters).
       * This point is equidistant from all sides of the box.
       *
       * @member center
       * @type {number[]}
       */
      center: number[];
      //   size;
      /**
       * The width of the InteractionBox in millimeters, measured along the x-axis.
       *
       * @member width
       * @type {number}
       * @memberof Leap.InteractionBox.prototype
       */
      width: number;
      /**
       * The height of the InteractionBox in millimeters, measured along the y-axis.
       *
       * @member height
       * @type {number}
       * @memberof Leap.InteractionBox.prototype
       */
      height: number;
      /**
       * The depth of the InteractionBox in millimeters, measured along the z-axis.
       *
       * @member depth
       * @type {number}
       * @memberof Leap.InteractionBox.prototype
       */
      depth: number;
      /**
       * Converts a position defined by normalized InteractionBox coordinates
       * into device coordinates in millimeters.
       *
       * This function performs the inverse of normalizePoint().
       *
       * @method denormalizePoint
       * @memberof Leap.InteractionBox.prototype
       * @param {number[]} normalizedPosition The input position in InteractionBox coordinates.
       * @returns {import("gl-matrix").vec3} The corresponding denormalized position in device coordinates.
       */
      denormalizePoint(normalizedPosition: number[]): import("gl-matrix").vec3;
      /**
       * Normalizes the coordinates of a point using the interaction box.
       *
       * Coordinates from the Leap Motion frame of reference (millimeters) are
       * converted to a range of [0..1] such that the minimum value of the
       * InteractionBox maps to 0 and the maximum value of the InteractionBox maps to 1.
       *
       * @method normalizePoint
       * @memberof Leap.InteractionBox.prototype
       * @param {number[]} position The input position in device coordinates.
       * @param {Boolean} clamp Whether or not to limit the output value to the range [0,1]
       * when the input position is outside the InteractionBox. Defaults to true.
       * @returns {import("gl-matrix").vec3} The normalized position.
       */
      normalizePoint(position: number, clamp: boolean): import("gl-matrix").vec3;
      /**
       * Writes a brief, human readable description of the InteractionBox object.
       *
       * @method toString
       * @memberof Leap.InteractionBox.prototype
       * @returns {String} A description of the InteractionBox object as a string.
       */
      toString(): string;
      /**
       * An invalid InteractionBox object.
       *
       * You can use this InteractionBox instance in comparisons testing
       * whether a given InteractionBox instance is valid or invalid. (You can also use the
       * InteractionBox.valid property.)
       *
       * @static
       * @type {Leap.InteractionBox}
       * @name Invalid
       * @memberof Leap.InteractionBox
       */
      Invalid: { valid: false };
    }
    export class CircularBuffer<T> {
      constructor(size: number);
      pos: number;
      size: number;
      get(i: number): T | undefined;
      push(o: T): number;
    }
    export namespace UI {
      export class Region extends import("events").EventEmitter {
        constructor(public start: number, public end: number);
        enteredFrame: null | Frame;
        hasPointables(frame: Frame): boolean;
        listener(opts?: {
          nearThreshold?: number;
        }): (frame: Frame) => ReturnType<Region["updatePosition"]>;
        clipper(): Frame | null;
        setupNearRegion(distance: number): void;
        updatePosition(frame: Frame): Frame;
        normalize(position: import("gl-matrix").vec3): Vector;
        mapToXY(
          position: import("gl-matrix").vec3,
          width: number,
          height: number
        ): import("gl-matrix").vec3;
      }
      export const Cursor: () => (frame: Frame) => Frame;
    }
    export class JSONProtocol {}
    export { default as glMatrix } from "gl-matrix";
    export { mat3 } from "gl-matrix";
    export { vec3 } from "gl-matrix";
    export const loopController: undefined | Controller;
    export const version: {
      full: string;
      major: number;
      minor: number;
      dot: number;
    };
    export { EventEmitter } from "events";
  
    /**
     * The Leap.loop() function passes a frame of Leap data to your
     * callback function and then calls window.requestAnimationFrame() after
     * executing your callback function.
     *
     * Leap.loop() sets up the Leap controller and WebSocket connection for you.
     * You do not need to create your own controller when using this method.
     *
     * Your callback function is called on an interval determined by the client
     * browser. Typically, this is on an interval of 60 frames/second. The most
     * recent frame of Leap data is passed to your callback function. If the Leap
     * is producing frames at a slower rate than the browser frame rate, the same
     * frame of Leap data can be passed to your function in successive animation
     * updates.
     *
     * As an alternative, you can create your own Controller object and use a
     * {@link Controller#onFrame onFrame} callback to process the data at
     * the frame rate of the Leap device. See {@link Controller} for an
     * example.
     *
     * @method Leap.loop
     * @param {function} callback A function called when the browser is ready to
     * draw to the screen. The most recent {@link Frame} object is passed to
     * your callback function.
     *
     * ```javascript
     *    Leap.loop( function( frame ) {
     *        // ... your code here
     *    })
     * ```
     */
  
    export function loop(callback: (frame: Frame) => void): Controller;
    export function loop(
      opts: object,
      callback: (frame: Frame) => void
    ): Controller;
  
    /**
     * Convenience method for Leap.Controller.plugin
     */
    export const plugin: (name: string, options: any) => void;
  }